# 其他 C++ 特性 #

## 变长数组和 alloca() ##
	我们不允许使用变长数组和 `alloca()`.

优点:
:	变长数组具有浑然天成的语法. 变长数组和 `alloca()` 也都很高效.

缺点:
:	变长数组和 `alloca()` 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: "在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了".

结论:
:	使用安全的内存分配器, 如 `scoped_ptr` / `scoped_array`.

## 友元 ##
	由于其会导致过度的复杂化, 我们不允许使用友元.

## 异常 ##
	我们不使用 C++ 异常.

优点:
:	-	异常允许上层应用决定如何处理在底层嵌套函数中 "不可能出现的" 失败, 不像错误码记录那么含糊又易出错;

		-很多现代语言都使用异常. 引入异常使得 C++ 与 Python, Java 以及其它 C++ 相近的语言更加兼容.
		-许多第三方 C++ 库使用异常, 禁用异常将导致很难集成这些库.
		-异常是处理构造函数失败的唯一方法. 虽然可以通过工厂函数或 `Init()` 方法替代异常, 但他们分别需要堆分配或新的 "无效" 状态；
		-在测试框架中使用异常确实很方便.

缺点:
:	-	在现有函数中添加 `throw` 语句时, 你必须检查所有调用点.
		所有调用点得至少有基本的异常安全保护, 否则永远捕获不到异常,
		只好 "开心的" 接受程序终止的结果. 例如, 如果 `f()` 调用了 `g()`,
		`g()` 又调用了 `h()`, `h` 抛出的异常被 `f` 捕获, `g` 要当心了, 很可能会因疏忽而未被妥善清理.
	-	更普遍的情况是, 如果使用异常, 光凭查看代码是很难评估程序的控制流:
		函数返回点可能在你意料之外. 这回导致代码管理和调试困难.
		你可以通过规定何时何地如何使用异常来降低开销,
		但是让开发人员必须掌握并理解这些规定带来的代价更大.
	-	异常安全要求同时采用 RAII 和不同编程实践.
		要想轻松编写正确的异常安全代码, 需要大量的支撑机制配合. 另外,
		要避免代码读者去理解整个调用结构图,
		异常安全代码必须把写持久化状态的逻辑部分隔离到 "提交" 阶段.
		它在带来好处的同时, 还有成本 (也许你不得不为了隔离 "提交" 	而整出令人费解的代码).
		允许使用异常会驱使我们不断为此付出代价,
		即使我们觉得这很不划算.
	-	启用异常使生成的二进制文件体积变大, 延长了编译时间
		(或许影响不大), 还可能增加地址空间压力;
	
	-	异常的实用性可能会怂恿开发人员在不恰当的时候抛出异常,
		或者在不安全的地方从异常中恢复. 例如,
		处理非法用户输入时就不应该抛出异常. 如果我们要完全列出这些约束,
 这份风格指南会长出很多!

结论:
:	从表面上看, 使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码,
	引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散,
	在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数
	C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.

	鉴于 Google 现有代码不接受异常,
	在现有代码中使用异常比在新项目中使用的代价多少要大一些.
	迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案,
	如错误代码, 断言等会造成严重负担.

	我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上.
	我们希望在 Google 使用我们自己的开源项目,
	但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google
	的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.

	对于 Windows 代码来说, 有个 特例.

## 运行时类型识别 ##
	我们禁止使用 RTTI.

定义:
:	RTTI 允许程序员在运行时识别 C++ 类对象的类型.

优点:
:	RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时,
	用来验证一个新建对象是否为期望的动态类型.

	除测试外, 极少用到.

缺点:
:	在运行时判断类型通常意味着设计问题.
	如果你需要在运行期间确定一个对象的类型,
	这通常说明你需要考虑重新设计你的类.

结论:
:	除单元测试外, 不要使用 RTTI.
	如果你发现自己不得不写一些行为逻辑取决于对象类型的代码,
	考虑换一种方式判断对象类型.

	如果要实现根据子类类型来确定执行不同逻辑代码, 虚函数无疑更合适.
	在对象内部就可以处理类型识别问题.

	如果要在对象外部的代码中判断类型, 考虑使用双重分派方案,
	如访问者模式. 可以方便的在对象本身之外确定类的类型.

	如果你认为上面的方法你真的掌握不了, 你可以使用 RTTI, 但务必请三思
	:-) . 不要试图手工实现一个貌似 RTTI 的替代方案, 我们反对使用 RTTI
	的理由, 同样适用于那些在类型继承体系上使用类型标签的替代方案.

## 类型转换 ##
	使用 C++ 的类型转换, 如 `static_cast<>()`.
	不要使用 `int y = (int)x` 或 `int y = int(x)` 等转换方式;

定义:
:	C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.

优点:
:	C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如`(int)3.5`), 有时是在做类型转换 (如 `(int)"hello"`). 另外, C++ 的类型转换在查找时更醒目.

缺点:
:   恶心的语法.

结论:
:   不要使用 C 风格类型转换. 而应该使用 C++ 风格.
	-	用 `static_cast` 替代 C 风格的值转换,
		或某个类指针需要明确的向上转换为父类指针时.
	-	用 `const_cast` 去掉 `const` 限定符.
	-	用 `reinterpret_cast` 指针类型和整型或其它指针之间进行不安全的相互转换.
		仅在你对所做一切了然于心时使用.
	-	`dynamic_cast` 测试代码以外不要使用. 除非是单元测试.

## 流 ##
	只在记录日志时使用流.

定义:
:	流用来替代 `printf()` 和 `scanf()`.

优点:
:	有了流, 在打印时不需要关心对象的类型.
	不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 `printf`
	也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.

缺点:
:	流使得 `pread()` 等功能函数很难执行. 如果不使用 `printf`
	风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 `%.*s`)
	用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s),
	而这一点对于软件国际化很有用.

结论:
:	不要使用流, 除非是日志接口需要. 使用 `printf` 之类的代替.

	使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.

## `const` 的使用 ##
	我们强烈建议你在任何可能的情况下都要使用 `const`.

定义:
:	在声明的变量或参数前加上关键字 `const` 用于指明变量值不可被篡改 (如
	`const int foo` ). 为类中的函数加上 `const`
	限定符表明该函数不会修改类成员变量的状态 (如
	`class Foo { int Bar(char c) const; };`).

优点:
:	大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地,
	也能生成更好的代码. 人们对编写正确的代码更加自信,
	因为他们知道所调用的函数被限定了能或不能修改变量值.
	即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.

缺点:
:	`const` 是入侵性的: 如果你向一个函数传入 `const` 变量,
	函数原型声明中也必须对应 `const` 参数 (否则变量需要 `const_cast`
	类型转换), 在调用库函数时显得尤其麻烦.

结论:
:	`const` 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障;
	便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 `const`:

	-	如果函数不会修改传入的引用或指针类型参数, 该参数应声明为 `const`.
	-	尽可能将函数声明为 `const`. 访问函数应该总是 `const`.
		其他不会修改任何数据成员, 未调用非 `const` 函数,
		不会返回数据成员非 `const` 指针或引用的函数也应该声明成 `const`.
	-	如果数据成员在对象构造之后不再发生变化, 可将其定义为 `const`.

	然而, 也不要发了疯似的使用 `const`. 像 `const int * const * const x;` 就有些过了, 虽然它非常精确的描述了常量 `x`. 关注真正有帮助意义的信息: 前面的例子写成 `const int** x` 就够了.

`const` 的位置:
:	有人喜欢 `int const *foo` 形式, 不喜欢 `const int* foo`,
	他们认为前者更一致因此可读性也更好: 遵循了 `const`
	总位于其描述的对象之后的原则. 但是一致性原则不适用于此,
	"不要过度使用" 的声明可以取消大部分你原本想保持的一致性. 将 `const`
	放在前面才更易读, 因为在自然语言中形容词 (`const`) 是在名词 (`int`)
	之前.

	这是说, 我们提倡但不强制 `const` 在前. 但要保持代码的一致性!


## 0 和 NULL ##
	整数用 `0`, 实数用 `0.0`, 指针用 `NULL`, 字符 (串) 用 `'\0'`.

整数用 `0`, 实数用 `0.0`, 这一点是毫无争议的.

对于指针 (地址值), 到底是用 `0` 还是 `NULL`, Bjarne Stroustrup 建议使用最原始的 `0`.
我们建议使用看上去像是指针的 `NULL`. 

事实上一些 C++ 编译器 (如 gcc 4.1.0) 对 `NULL` 进行了特殊的定义, 可以给出有用的警告信息, 尤其是 `sizeof(NULL)` 和 `sizeof(0)` 不相等的情况.

字符 (串) 用 `'\0'`, 不仅类型正确而且可读性好.

## sizeof ##
	尽可能用 `sizeof(varname)` 代替 `sizeof(type)`.

-	使用 `sizeof(varname)` 是因为当代码中变量类型改变时会自动更新. 某些情况下 `sizeof(type)` 或许有意义, 但还是要尽量避免, 因为它会导致变量类型改变后不能同步.

## assert断言##
定义:
:	断言是用来在运行时判断程序是否按照预定的逻辑运行(主要在 `Debug` 配置下), 其会在不达成条件时抛出调试信息, 并终止程序运行.

优点:
:	其可以方便程序调试, 在中断时可以提供较多的有效信息, 从而便于修正.
	在定义 `NDEBUG` 宏后会被忽略, 因此其在 `Release` 版本中不执行也不会产生任何对性能的不良影响.

缺点:
:	其实质是函数宏, 在C++中并不提倡使用.

结论:
:	建议在函数输入参数易参数错误时采用 `assert` 对输入参数及输出进行判断, 这样易于定位错误.
	在 `Release` 版中定义`NDEBUG` 宏, 使其失效.

## 智能指针 ##
	如果确实需要使用智能指针的话, `scoped_ptr` 完全可以胜任.
	你应该只在非常特定的情况下使用 `std::tr1::shared_ptr`, 例如 STL
	容器中的对象. 任何情况下都不要使用 `auto_ptr`.

"智能" 指针看上去是指针, 其实是附加了语义的对象. 以 `scoped_ptr` 为例,
`scoped_ptr` 被销毁时, 它会删除所指向的对象. `shared_ptr` 也是如此,
并且 `shared_ptr` 实现了引用计数, 所以最后一个 `shared_ptr` 对象析构时,
如果检测到引用次数为 0，就会销毁所指向的对象.

一般来说，我们倾向于设计对象隶属明确的代码,最明确的对象隶属是根本不使用指针,
直接将对象作为一个作用域或局部变量使用. 另一种极端做法是,引用计数指针不属于任何对象.
这种方法的问题是容易导致循环引用, 或者导致某个对象无法删除的诡异状态, 而且在每一次拷贝或赋值时连原子操作都会很慢.

虽然不推荐使用引用计数指针, 但有些时候它们的确是最简单有效的解决方案.

## 宏 ##

-	使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.
-	宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.
-	值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被`const` 变量代替. 用宏 "缩写" 长变量名可被引用代替. 用宏进行条件编译...这个, 千万别这么做, 会令测试更加痛苦 (`#define` 防止头文件重包含当然是个特例).
-	宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 `#` 字符串化, 用 `##` 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.
-	下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:

	-	不要在 `.h` 文件中定义宏.
	-	在马上要使用时才进行 `#define`, 使用后要立即 `#undef`.
	-	不要只是对已经存在的宏使用\#undef，选择一个不会冲突的名称；
	-	不要试图使用展开后会导致 C++ 构造不稳定的宏.
